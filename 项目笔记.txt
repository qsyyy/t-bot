#安装git后需要进行第一次设置。
git config --global user.name "qsyyy"
git config --global user.email "xu96078@gmail.com"

#然后配置ssh
ssh-keygen -t rsa -b 4096 -C "your_email@example.com" #直接回车3次默认设置即可

#然后去默认保存路径为~/.ssh/id_rsa.pub 复制公钥粘贴到github上。



#创建本地项目  ：先进目录，然后
	git init
	
	
	#创建git库，命名为t-bot
	
	#需要注意的是本地创建的分支名称一般是master，但是远程是main所以需要先更改本地分支。
	git branch -M main #修改本地分支名称


	
	
	git remote add origin git@github.com:qsyyy/t-bot.git #关联远程仓库
	
	git add .  #添加进暂存区
	
	git commit -m "Initial commit" #提交更改到本地仓房中。
	
	
	git push -u origin main  #d第一次push时使用-u命令绑定到main分支，推送代码到main分支上
	
	git push #第二次直接push就行。
	
	{
	第一次从远程拉取仓库：
	如果分支是main，项目是t-bot
	首先要激活仓库
	选择一个目录，
	git init
	然后关联仓库 
	git remote add origin git@github.com:qsyyy/t-bot.git
	
	然后修改分支名！
	git branch -M main #修改本地分支名称
	if {本地已有旧版未提交的文件}
		git reset --hard origin/main #丢弃本地修改
		git clean -fd  # 删除未跟踪的文件和目录
		
		else if {保留更改}
				git stash        # 暂存本地修改
				git pull origin main
				git stash pop    # 恢复暂存的修改（可能需要解决冲突）
		else if 
				git pull origin main
				
	以后直接git pull就行

	}
	
	
	项目依赖的问题：依赖写进requirements里，可以一键安装
	pip install -r requirements.txt
	
	
	bot修改的思路：15分钟一次的cd，
	
	相关信息：免费版推特api，每月限额100次请求。每次请求都有15分钟的冷却时间。

我在修改我的代码，把本来用于telegram频道中接受推特链接并格式化输出推文内容的bot修改成拉取我的推特点赞的推文，并格式化后发送到频道中。这是我整理出来的功能需求。


	我需要你帮忙修改代码。而且由于我本身并不会编程，所以如果有需要修改的地方请给出详细的代码位置，并用修改前后的代码互相对照。若需要修改很多代码。请直接输出修改后的完整代码。如果一次输出写不完就结束了，请在下一个回复中直接输出完整代码

	我已经成功的运行项目，但是现在在认证callback的时候卡住了

	

目前的环境：anaconda  python version : 3.12.7
环境中已经安装的依赖：python-telegram-bot[job-queue]==20.3
tweepy==4.14.0
python-dotenv==1.0.0

	
需求：

bot的触发方式：调整成每日固定a.m.6:00和p.m.10:00各运行一次，
	另设在telegram频道中收到指定命令/updata时触发运行。且在触发运行后将频道中的启动指令那条消息删除。
	
	
bot的功能：
	1.拉取指定用户的点赞列表。数量为100。（目前在测试阶段，暂时设为25）
	2.由于liked_tweets端点，返回的推文默认是按用户点赞的时间倒序排列，且不支持查看具体的点赞时间。
	在数据库字段ast_processed_id中保存拉取的点赞列表最新的推文id，
	每次运行后拉取的点赞数据与上一次的记录互相比较。找出新增的点赞。然后把此次最新的点赞推文id更新到new_likes_id。
	
	3.需要获取的内容有？用户昵称，用户主页url，推文，图片，媒体，gif。
	获取到媒体后，筛出最高比特率的视频url。存到对应的表中。我记得gif在推特上也是mp4格式的，就按视频一样处理吧。
	
	4.根据获取到的新增推文构造telegram消息。将每条推特都通过telegram bot的api发送到频道中。
	
	5.构造telegram消息的要求：
		5.1 一般来说推文附带的媒体不会超过4张图片或者视频。所以我们可以直接把推文附带的图片和视频跟推文打包在一起发送。
		5.2 所有推文都单独发送
		5.3 构造的格式。  1）媒体在消息的上方。
		2）下面第一行的文字是推文发送者的昵称。该昵称附上发送者的主页url，点击可以跳转。昵称后面加个冒号。
		3）另起一行是正文文本。
		4）再另起一行将推文的url放在这里。
	
	6.由于推特的免费api的请求数极少。所以给bot的运行也设置冷却时间，防止误启动。每天只允许一次手动运行。保证请求次数不超过一百次/月
	7.还需要有报错代码。
	
	

	
	
报错日志：
{
2025-02-19 04:02:00,334 - __main__ - INFO - 尝试认证参数: client_id=ZzVYc..., client_secret=zwgCw...
2025-02-19 04:02:00,334 - __main__ - ERROR - 认证失败详情: ❌ 认证失败：'TwitterAuthManager' object has no attribute '_basic_auth'
Traceback (most recent call last):
  File "E:\Developer\projects\t-bot\main.py", line 318, in handle_callback
    "Authorization": f"Basic {auth_manager._basic_auth()}"  # 新增基础认证方法
AttributeError: 'TwitterAuthManager' object has no attribute '_basic_auth'
}

#https://github.com/PLhery/node-twitter-api-v2/issues/475

# 问题在于认证流程不对
下面是github上面有人提到的解决方式：
{
Twitter has basically 3 OAuth methods:

OAuth v1
OAuth v2 User Context
OAuth v2 Application Only
By passing the Bearer token from Twitter's Developer Dashboard you opt-in for the last option. With Application Only flow you basically have access to only public information, if you want to use for example POST endpoints, like the one for creating a tweet, you need to use User Context OAuth.

That might be helpful
https://github.com/PLhery/node-twitter-api-v2/blob/master/doc/auth.md#user-wide-authentication-flow

So in summary:
You have to somehow obtain an access token.

Use generateOAuth2AuthLink fn to generate an auth url
const callbackUrl = 'http://127.0.0.1:3001/callback';
const twitterClient = new TwitterApi({
	clientId: TWITTER_CREDENTIALS.CLIENT_ID,
	clientSecret: TWITTER_CREDENTIALS.CLIENT_SECRET,
});

const state = randomUUID();

const authUrl = this.twitterClient.generateOAuth2AuthLink(
	callbackUrl,
	{
		state,
		scope: ['tweet.read', 'tweet.write', 'users.read', 'offline.access'],
	},
);
const codeVerifier = authUrl.codeVerified;
Open the generated URL and sign in with twitter.
Create a callback endpoint, where you can be redirected after a successful auth on Twitter page.
You should get code & state in query params
const tokenResult = await this.twitterClient.loginWithOAuth2({
	code,
	codeVerifier,
	redirectUri: callbackUrl,
});
Token result will consist of accessToken, refreshToken, expiresIn & scope.
Save them somewhere and use the accessToken to create a different twitter client.
const twitterClient = new TwitterApi(accessToken);

const response = await twitterClient.v2.tweet(data.text);
Create an interceptor that would handle the case when Twitter API throws 401 error and refresh the token using the refreshToken and refreshOAuth2Token method.
}
